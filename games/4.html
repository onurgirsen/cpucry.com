<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Reflective Laser – Ultra Fast</title>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "VideoGame",
    "name": "Reflective Laser – Ultra Fast",
    "url": "https://www.cpucry.com/games/4.html",
    "applicationCategory": "BrowserGame",
    "operatingSystem": "Web",
    "genre": "Arcade, Physics",
    "author": {"@type": "Person", "name": "Onur Girşen"},
    "description": "High-speed reflective laser browser game with customizable performance and visual settings."
  }
  </script>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; }
    body { margin: 0; background: #070d1c; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }

    /* Bottom toolbar (compact) */
    .toolbar {
      position: fixed; left: 50%; bottom: 8px; transform: translateX(-50%);
      display: flex; gap: 8px; align-items: center; flex-wrap: nowrap;
      max-width: 96vw; overflow-x: auto; white-space: nowrap;
      padding: 6px 8px; background: rgba(10,14,24,.65); backdrop-filter: blur(4px);
      border: 1px solid rgba(255,255,255,.08); border-radius: 12px; color: #dbeafe;
      box-shadow: 0 10px 30px rgba(0,0,0,.35); font-size: 11px;
    }
    .toolbar .group { display: inline-flex; gap: 6px; align-items: center; }
    .toolbar .sp { width: 6px; height: 1px; opacity: 0; }

    .toolbar button, .toolbar input[type="range"], .toolbar select, .toolbar label, .toolbar .badge {
      appearance: none; border: 1px solid rgba(255,255,255,.10); background: rgba(255,255,255,.06);
      color: #e2e8f0; padding: 4px 6px; border-radius: 9px; font-weight: 600; cursor: pointer; font-size: 11px;
    }
    .toolbar button:hover { background: rgba(255,255,255,.12); }
    .toolbar input[type="checkbox"] { transform: translateY(1px); margin-right: 4px; accent-color: #60a5fa; }
    .toolbar small { color: #9fb3c8; font-size: 10px; }
    .badge { cursor: default; }

    /* Frame border for room feel */
    .frame-border { position: fixed; inset: 0; pointer-events: none; }
  </style>
</head>
<body>
  <canvas id="stage"></canvas>
  <div class="frame-border" aria-hidden="true"></div>

  <!-- Bottom toolbar (EN) -->
  <div class="toolbar" id="toolbar">
    <span class="badge">Reflective Laser</span>

    <div class="group">
      <button id="restart">Restart (R)</button>
      <button id="pause">Pause / Resume (Space)</button>
    </div>

    <div class="group">
      <label><input type="checkbox" id="perfMode" checked />Performance</label>
      <label><input type="checkbox" id="glowOn" checked />Glow</label>
      <label><input type="checkbox" id="headGlow" />Head glow</label>
    </div>

    <div class="group">
      <small>Speed</small>
      <input id="speed" type="range" min="80" max="600" value="220" />
      <small id="speedLabel">220 px/s</small>
    </div>

    <div class="group">
      <small>Quality</small>
      <select id="quality">
        <option value="0.35">Ultra</option>
        <option value="0.5" selected>High</option>
        <option value="0.75">Medium</option>
        <option value="1">Max</option>
      </select>
    </div>

    <div class="group">
      <small>Blur</small>
      <input id="blur" type="range" min="0" max="16" value="8" />
      <small id="blurLabel">8px</small>
    </div>

    <div class="group">
      <small>Split</small>
      <input id="delta" type="range" min="1" max="12" value="5" />
      <small id="deltaLabel">±5°</small>
    </div>

    <div class="group">
      <small>Trail</small>
      <input id="trail" type="range" min="0" max="50" value="35" />
      <small id="trailLabel">0.35</small>
    </div>

    <div class="group">
      <small id="stats">—</small>
    </div>
  </div>

  <script>
    // ===================== Helpers =====================
    const TAU = Math.PI * 2; const DEG = Math.PI / 180;
    const rand=(a,b)=>Math.random()*(b-a)+a; const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
    function normalize(x,y){ const l=Math.hypot(x,y)||1e-6; return {x:x/l,y:y/l}; }
    function rotate(v,a){ const c=Math.cos(a), s=Math.sin(a); return {x:v.x*c - v.y*s, y:v.x*s + v.y*c}; }
    function reflect(d,wall){ if(wall==='left'||wall==='right') return {x:-d.x,y:d.y}; if(wall==='top'||wall==='bottom') return {x:d.x,y:-d.y}; return {x:-d.x, y:-d.y}; }
    function measurePxPerCm(){ const el=document.createElement('div'); el.style.width='1cm'; el.style.position='absolute'; el.style.opacity='0'; document.body.appendChild(el); const px=el.getBoundingClientRect().width||37.795; el.remove(); return px; }
    function randomLaserColor(){ const h=Math.floor(rand(0,360)); return `hsl(${h} 100% 60%)`; }

    // ===================== Scene =====================
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });

    // Low-res glow buffer
    let glowCanvas = document.createElement('canvas');
    let glowCtx = glowCanvas.getContext('2d', { alpha: true });

    const ui = {
      stats: document.getElementById('stats'), restart: document.getElementById('restart'), pause: document.getElementById('pause'),
      speed: document.getElementById('speed'), speedLabel: document.getElementById('speedLabel'),
      delta: document.getElementById('delta'), deltaLabel: document.getElementById('deltaLabel'),
      quality: document.getElementById('quality'), blur: document.getElementById('blur'), blurLabel: document.getElementById('blurLabel'),
      trail: document.getElementById('trail'), trailLabel: document.getElementById('trailLabel'),
      headGlow: document.getElementById('headGlow'), glowOn: document.getElementById('glowOn'), perfMode: document.getElementById('perfMode')
    };

    let DPR = Math.max(1, window.devicePixelRatio || 1);
    let W=0, H=0, pxPerCm=measurePxPerCm();

    const state = {
      beams: [], nextId: 1, paused: false,
      speed: Number(ui.speed.value), deltaDeg: Number(ui.delta.value), lengthPx: 0,
      maxBeams: 999999999,
      color: randomLaserColor(),
      qualityScale: Number(ui.quality.value), blurPx: Number(ui.blur.value), trailAlpha: Number(ui.trail.value)/100,
      glowEnabled: ui.glowOn.checked, headGlow: ui.headGlow.checked, perfMode: ui.perfMode.checked,
    };

    function resize(){
      DPR = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(window.innerWidth * DPR);
      canvas.height = Math.floor(window.innerHeight * DPR);
      ctx.setTransform(1,0,0,1,0,0); ctx.scale(DPR, DPR);
      W = canvas.width / DPR; H = canvas.height / DPR;

      const s = clamp(state.qualityScale, 0.25, 1);
      glowCanvas.width = Math.max(1, Math.floor(W * s));
      glowCanvas.height = Math.max(1, Math.floor(H * s));
      glowCtx.setTransform(1,0,0,1,0,0);
      glowCtx.scale(s, s);

      pxPerCm = measurePxPerCm();
    }
    window.addEventListener('resize', resize, { passive: true });

    // ===================== Beam model =====================
    function makeBeam({ head, dir, generation=0, canSinkFirstHit=false }){
      return { id: state.nextId++, head: {x: head.x, y: head.y}, dir: normalize(dir.x, dir.y),
               generation, canSinkFirstHit, sinking:false, sinkWall:null, removed:false };
    }
    const tailPoint = (b)=>({ x: b.head.x - b.dir.x * state.lengthPx, y: b.head.y - b.dir.y * state.lengthPx });

    function computeCollision(b){
      const {head, dir} = b, S = state.speed; let tMin = Infinity, wall = null;
      if (dir.x>0){ const t=(W-head.x)/(dir.x*S); if(t>=0&&t<tMin){ tMin=t; wall='right'; }}
      if (dir.x<0){ const t=(0-head.x)/(dir.x*S); if(t>=0&&t<tMin){ tMin=t; wall='left'; }}
      if (dir.y>0){ const t=(H-head.y)/(dir.y*S); if(t>=0&&t<tMin){ tMin=t; wall='bottom'; }}
      if (dir.y<0){ const t=(0-head.y)/(dir.y*S); if(t>=0&&t<tMin){ tMin=t; wall='top'; }}
      const eps=1e-6; const tX = dir.x>0?(W-head.x)/(dir.x*S):dir.x<0?(0-head.x)/(dir.x*S):Infinity;
      const tY = dir.y>0?(H-head.y)/(dir.y*S):dir.y<0?(0-head.y)/(dir.y*S):Infinity;
      if (Math.abs(tX-tY)<eps && (tX!==Infinity || tY!==Infinity)) { const tC = Math.min(tX,tY); if (tC>=0 && tC < tMin+eps) { tMin=tC; wall='corner'; } }
      if (!isFinite(tMin)) return { t:null, wall:null };
      return { t:tMin, wall };
    }

    const moveHead=(b,dt)=>{ b.head.x += b.dir.x * state.speed * dt; b.head.y += b.dir.y * state.speed * dt; };

    function inferCornerWall(b){ const d=b.dir; if(Math.abs(d.x)>Math.abs(d.y)) return d.x>0?'right':'left'; else return d.y>0?'bottom':'top'; }
    function segmentFullyBeyondWall(b){ if(!b.sinking||!b.sinkWall) return false; const t=tailPoint(b), h=b.head; switch(b.sinkWall){
      case 'right': return Math.min(t.x,h.x) >= W + 0.5;
      case 'left':  return Math.max(t.x,h.x) <= -0.5;
      case 'bottom':return Math.min(t.y,h.y) >= H + 0.5;
      case 'top':   return Math.max(t.y,h.y) <= -0.5;
      case 'corner': const outX=(Math.min(t.x,h.x)>=W+0.5)||(Math.max(t.x,h.x)<=-0.5); const outY=(Math.min(t.y,h.y)>=H+0.5)||(Math.max(t.y,h.y)<=-0.5); return outX && outY; }
      return false; }

    function spawnChildren(hit, rDir, parent){
      if (state.beams.length > state.maxBeams - 4) return;
      const delta = state.deltaDeg * DEG; const d1 = rotate(rDir, -delta), d2 = rotate(rDir, +delta);
      const eps = 0.6; const gen = parent.generation + 1;
      // Each child sinks on its first hit (visual parity)
      const b1 = makeBeam({ head:{x:hit.x+d1.x*eps, y:hit.y+d1.y*eps}, dir:d1, generation:gen, canSinkFirstHit:true });
      const b2 = makeBeam({ head:{x:hit.x+d2.x*eps, y:hit.y+d2.y*eps}, dir:d2, generation:gen, canSinkFirstHit:true });
      state.beams.push(b1,b2);
    }

    function stepBeam(b, dt){
      if (b.removed) return;
      if (b.sinking){ moveHead(b, dt); if (segmentFullyBeyondWall(b)) b.removed = true; return; }
      const {t, wall} = computeCollision(b);
      if (t === null) { moveHead(b, dt); return; }
      if (t > dt) { moveHead(b, dt); return; }
      // collision happens this frame
      moveHead(b, t); const hit = { x: b.head.x, y: b.head.y }; const rDir = reflect(b.dir, wall);
      if (b.canSinkFirstHit){ b.sinking = true; b.sinkWall = wall==='corner' ? inferCornerWall(b) : wall; b.canSinkFirstHit=false; spawnChildren(hit, rDir, b); return; }
      b.removed = true; spawnChildren(hit, rDir, b);
    }

    // ===================== Draw (fast path) =====================
    function drawFrame(){
      // Room fading trail
      ctx.globalCompositeOperation = 'source-over';
      ctx.filter = 'none';
      ctx.fillStyle = `rgba(5, 8, 16, ${state.trailAlpha})`;
      ctx.fillRect(0, 0, W, H);

      // Prepare glow buffer (optional)
      if (state.glowEnabled){
        glowCtx.setTransform(1,0,0,1,0,0);
        const s = clamp(state.qualityScale, 0.25, 1);
        glowCtx.clearRect(0, 0, W * s + 2, H * s + 2);
        glowCtx.scale(s, s);
      }

      // Group all segments by color (single color in this build)
      const colorGroups = new Map();
      const col = state.color; if (!colorGroups.has(col)) colorGroups.set(col, []);
      const arr = colorGroups.get(col);
      for (let i=0; i<state.beams.length; i++){
        const b = state.beams[i]; const t = tailPoint(b);
        arr.push(t.x, t.y, b.head.x, b.head.y);
      }

      // Glow strokes (thick at low-res)
      if (state.glowEnabled){
        glowCtx.globalCompositeOperation = 'source-over';
        glowCtx.lineCap = 'round'; glowCtx.lineJoin = 'round';
        for (const [c, data] of colorGroups){
          glowCtx.beginPath();
          for (let i=0; i<data.length; i+=4){ glowCtx.moveTo(data[i], data[i+1]); glowCtx.lineTo(data[i+2], data[i+3]); }
          glowCtx.lineWidth = state.perfMode ? 3.0 : 3.6; glowCtx.strokeStyle = c; glowCtx.stroke();
        }
        ctx.save(); ctx.globalCompositeOperation = 'lighter'; ctx.filter = state.blurPx > 0 ? `blur(${state.blurPx}px)` : 'none';
        ctx.drawImage(glowCanvas, 0, 0, W, H); ctx.restore(); ctx.filter = 'none';
      }

      // Crisp lines (single pass)
      ctx.save(); ctx.globalCompositeOperation = 'source-over'; ctx.lineCap = 'butt'; ctx.lineJoin = 'miter';
      for (const [c, data] of colorGroups){
        ctx.beginPath(); for (let i=0; i<data.length; i+=4){ ctx.moveTo(data[i], data[i+1]); ctx.lineTo(data[i+2], data[i+3]); }
        ctx.lineWidth = state.perfMode ? 1.1 : 1.4; ctx.strokeStyle = c; ctx.stroke();
      }
      ctx.restore();

      // Heads (optional)
      if (state.headGlow){ ctx.save(); ctx.globalCompositeOperation = 'lighter';
        for (let i=0; i<state.beams.length; i++){ const b = state.beams[i]; ctx.beginPath(); ctx.arc(b.head.x, b.head.y, 1.2, 0, TAU); ctx.fillStyle = state.color; ctx.fill(); }
        ctx.restore(); }

      // Frame stroke
      ctx.save(); ctx.strokeStyle='rgba(180,200,255,0.14)'; ctx.lineWidth=2; ctx.strokeRect(1,1,W-2,H-2); ctx.restore();
    }

    // ===================== Loop =====================
    let last = performance.now(); let frameCounter=0, fps=0, fpsLast=performance.now();
    function frame(now){
      const dt = Math.min(0.02, (now - last) / 1000); last = now;
      if (!state.paused){ for (let i=0; i<state.beams.length; i++) stepBeam(state.beams[i], dt); state.beams = state.beams.filter(b => !b.removed); }
      drawFrame();
      frameCounter++; if (now - fpsLast > 500){ fps = (frameCounter * 1000) / (now - fpsLast); fpsLast = now; frameCounter = 0; }
      ui.stats.textContent = `Beams: ${state.beams.length} | FPS: ${fps.toFixed(0)} | Length: ${state.lengthPx.toFixed(0)}px (~${(state.lengthPx/pxPerCm).toFixed(1)}cm)`;
      requestAnimationFrame(frame);
    }

    // ===================== Start / Interaction =====================
    function randomStart(){ const m=Math.max(20, Math.min(W,H)*0.05); return { x: rand(m, W-m), y: rand(m, H-m) }; }
    function resetGame(){ resize(); state.beams.length = 0; state.nextId = 1; state.lengthPx = rand(5,6) * pxPerCm; state.color = randomLaserColor(); const angle = rand(0, TAU); const dir = {x: Math.cos(angle), y: Math.sin(angle)}; const main = makeBeam({ head: randomStart(), dir, generation:0, canSinkFirstHit:true }); state.beams.push(main); }

    // Toolbar events
    ui.restart.addEventListener('click', resetGame);
    ui.pause.addEventListener('click', ()=>{ state.paused = !state.paused; });
    ui.speed.addEventListener('input', e=>{ state.speed = Number(e.target.value); ui.speedLabel.textContent = `${state.speed} px/s`; });
    ui.delta.addEventListener('input', e=>{ state.deltaDeg = Number(e.target.value); ui.deltaLabel.textContent = `±${state.deltaDeg}°`; });
    ui.quality.addEventListener('change', e=>{ state.qualityScale = Number(e.target.value); resize(); });
    ui.blur.addEventListener('input', e=>{ state.blurPx = Number(e.target.value); ui.blurLabel.textContent = `${state.blurPx}px`; });
    ui.trail.addEventListener('input', e=>{ state.trailAlpha = Number(e.target.value)/100; ui.trailLabel.textContent = `${state.trailAlpha.toFixed(2)}`; });
    ui.headGlow.addEventListener('change', e=>{ state.headGlow = e.target.checked; });
    ui.glowOn.addEventListener('change', e=>{ state.glowEnabled = e.target.checked; });
    ui.perfMode.addEventListener('change', e=>{ state.perfMode = e.target.checked; });
    window.addEventListener('keydown', ev=>{ if(ev.code==='Space'){ state.paused=!state.paused; ev.preventDefault(); } if(ev.key.toLowerCase()==='r') resetGame(); });

    // Go!
    resetGame(); requestAnimationFrame(frame);
  </script>
</body>
</html>