<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rotating Disk Game – Elastic Rope + Solid Disk (Fixed)</title>
  <style>
    :root { --bg:#0b0f14; --panel:#121821; --accent:#4dc3ff; --text:#e6f0ff; --muted:#a9b3c1; --danger:#ff5c7a; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 800px at 70% -10%,#152031 0%,var(--bg) 60%);color:var(--text);font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial;display:grid;grid-template-rows:auto 1fr auto;gap:12px;min-height:100dvh}
    header,footer{padding:10px 16px;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));border-bottom:1px solid rgba(255,255,255,.08)}
    header h1{font-size:18px;margin:0;letter-spacing:.3px}
    .wrap{display:grid;grid-template-columns:380px 1fr;gap:12px;padding:0 12px 12px}
    @media (max-width:900px){.wrap{grid-template-columns:1fr}}
    .panel{background:var(--panel);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.35),inset 0 1px 0 rgba(255,255,255,.04)}
    .controls{display:grid;gap:14px}
    .row{display:grid;gap:8px}
    .row.inline{grid-template-columns:1fr auto;align-items:center;gap:10px}
    .row label{font-weight:600;color:var(--muted)}
    input[type=range],input[type=number]{width:100%}
    input[type=number]{background:#0e1520;color:var(--text);border:1px solid rgba(255,255,255,.1);border-radius:10px;padding:8px 10px}
    .btns{display:flex;gap:10px;flex-wrap:wrap}
    button{appearance:none;border:0;cursor:pointer;border-radius:12px;padding:10px 14px;font-weight:700;color:#03121a;background:var(--accent);box-shadow:0 6px 16px rgba(77,195,255,.35)}
    button.ghost{background:transparent;color:var(--text);border:1px solid rgba(255,255,255,.12)}
    button.danger{background:var(--danger);color:#fff}
    .stats{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;margin-top:8px}
    .stat{background:#0e1520;border:1px solid rgba(255,255,255,.06);border-radius:12px;padding:10px;display:grid;gap:2px}
    .stat .k{color:var(--muted);font-size:12px}
    .stat .v{font-size:18px;font-weight:800;letter-spacing:.2px}
    canvas{width:100%;height:100%;display:block;background:radial-gradient(900px 600px at 40% 20%,#0e1520 0%,#0a0f14 60%);border-radius:16px}
    footer{color:var(--muted);font-size:13px;border-top:1px solid rgba(255,255,255,.08);border-bottom:none}
    .notice{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <header><h1>⟲ Rotating Disk Game – Elastic Rope + Solid Disk</h1></header>
  <div class="wrap">
    <aside class="panel">
      <div class="controls">
        <div class="row">
          <label>Number of Balls (x) <span id="ballsLabel" class="notice"></span></label>
          <input id="balls" type="range" min="1" max="20" step="1" value="10" />
        </div>
        <div class="row">
          <label>Acceleration Factor (y) – multiplied every second <span id="accelLabel" class="notice"></span></label>
          <input id="accel" type="range" min="0.8" max="3" step="0.01" value="1.01" />
        </div>
        <div class="row inline">
          <label>Initial Angular Speed Ω₀ (rad/s)</label>
          <input id="omega0" type="number" value="0.8" min="0" max="20" step="0.1" />
        </div>
        <div class="row inline">
          <label>Rope Rest Length L₀ (px)</label>
          <input id="len" type="number" value="160" min="40" max="400" step="10" />
        </div>
        <div class="row inline">
          <label>Rope Stiffness k (0–1)</label>
          <input id="stiff" type="number" value="0.35" min="0" max="1" step="0.05" />
        </div>
        <div class="row inline">
          <label>Rope Damping c (0–0.5)</label>
          <input id="sdamp" type="number" value="0.12" min="0" max="0.5" step="0.01" />
        </div>
        <div class="row inline">
          <label>Air Drag (0–1)</label>
          <input id="drag" type="number" value="0.01" min="0" max="0.2" step="0.005" />
        </div>
        <div class="row inline">
          <label>Ball Radius (px)</label>
          <input id="brad" type="number" value="10" min="4" max="30" step="1" />
        </div>
        <div class="btns">
          <button id="startBtn">Start</button>
          <button id="pauseBtn" class="ghost">Pause</button>
          <button id="resetBtn" class="danger">Reset</button>
        </div>
        <div class="stats">
          <div class="stat"><div class="k">Current Disk Speed Ω</div><div class="v" id="omegaOut">0</div></div>
          <div class="stat"><div class="k">Elapsed Time</div><div class="v" id="timeOut">0.00 s</div></div>
          <div class="stat"><div class="k">FPS</div><div class="v" id="fpsOut">0</div></div>
          <div class="stat"><div class="k">Estimated Max Tension</div><div class="v" id="tensionOut">0.0 arb.</div></div>
        </div>
        <div class="notice">Note: m=1 assumed; tension unit is relative (arb.). Rope cannot <b>pass through</b> the disk body (radius + half-space constraints).</div>
      </div>
    </aside>
    <main class="panel" style="padding:8px;display:grid"><canvas id="game"></canvas></main>
  </div>
  <footer>
    Rope: PBD/Verlet makes it <i>stretch</i> (k) and <i>damp</i> (c). Disk is solid; the rope cannot angle inward relative to the outward normal at the anchor.
  </footer>

  <script>
    // ==== Canvas & UI ====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const ballsEl = document.getElementById('balls');
    const accelEl = document.getElementById('accel');
    const omega0El = document.getElementById('omega0');
    const lenEl = document.getElementById('len');
    const stiffEl = document.getElementById('stiff');
    const sdampEl = document.getElementById('sdamp');
    const dragEl = document.getElementById('drag');
    const bradEl = document.getElementById('brad');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const ballsLabel = document.getElementById('ballsLabel');
    const accelLabel = document.getElementById('accelLabel');
    const omegaOut = document.getElementById('omegaOut');
    const timeOut = document.getElementById('timeOut');
    const fpsOut = document.getElementById('fpsOut');
    const tensionOut = document.getElementById('tensionOut');

    // ==== Simulation state ====
    let nBalls = 10, accel = 1.01, L0 = 160, k = 0.35, c = 0.12, drag = 0.01, ballR = 10;
    let diskAngle = 0, omega = 0.8, running = false;
    let lastTS = 0, elapsed = 0, fpsTimer = 0, frames = 0, secondBucket = 0;
    let cx = 0, cy = 0, diskR = 80;

    const balls = []; // {pos:{x,y}, prev:{x,y}, anchorOffset, tension}

    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

    function setParams(){
      nBalls = clamp(parseInt(ballsEl.value,10)||10, 1, 20);
      accel  = clamp(parseFloat(accelEl.value)||1.01, 0.8, 3);
      L0     = clamp(parseFloat(lenEl.value)||160, 40, 400);
      k      = clamp(parseFloat(stiffEl.value)||0.35, 0, 1);
      c      = clamp(parseFloat(sdampEl.value)||0.12, 0, 0.5);
      drag   = clamp(parseFloat(dragEl.value)||0.01, 0, 0.2);
      ballR  = clamp(parseFloat(bradEl.value)||10, 4, 30);
      omega  = clamp(parseFloat(omega0El.value)||0.8, 0, 50);
      ballsLabel.textContent = `(current: ${nBalls})`;
      accelLabel.textContent = `(current: ${accel.toFixed(2)})`;
    }

    function resize(){
      const dpr = Math.max(1, window.devicePixelRatio||1);
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width*dpr);
      canvas.height = Math.floor(rect.height*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      const w = rect.width, h = rect.height; cx = w/2; cy = h/2; diskR = Math.max(24, Math.min(w,h)*0.10);
    }
    new ResizeObserver(resize).observe(canvas);

    function resetWorld(){
      balls.length = 0; setParams();
      for(let i=0;i<nBalls;i++){
        const off = (i*2*Math.PI)/nBalls;
        const ax = cx + Math.cos(diskAngle+off)*diskR;
        const ay = cy + Math.sin(diskAngle+off)*diskR;
        const px = ax + Math.cos(diskAngle+off)*(L0+10);
        const py = ay + Math.sin(diskAngle+off)*(L0+10);
        balls.push({ pos:{x:px,y:py}, prev:{x:px,y:py}, anchorOffset:off, tension:0 });
      }
      elapsed=0; lastTS=0; fpsTimer=0; frames=0; secondBucket=0; diskAngle=0;
      omega = clamp(parseFloat(omega0El.value)||0.8, 0, 50);
      drawScene(); updateUI();
    }

    function anchorOf(b){
      return { x: cx + Math.cos(diskAngle + b.anchorOffset)*diskR,
               y: cy + Math.sin(diskAngle + b.anchorOffset)*diskR };
    }

    // Keep rope outside disk (half-space constraint along outward normal)
    function enforceHalfSpace(pos, a){
      const nx = (a.x-cx), ny = (a.y-cy);
      const len = Math.hypot(nx,ny)||1; const n = {x:nx/len, y:ny/len};
      const rx = pos.x-a.x, ry = pos.y-a.y;
      const d = rx*n.x + ry*n.y;
      if(d < 0){ // push outside along outward normal
        const eps=0.5; pos.x += n.x*(-d+eps); pos.y += n.y*(-d+eps);
      }
    }

    // Ball vs solid disk collision
    function collideDisk(pos){
      const dx = pos.x-cx, dy = pos.y-cy; const r = Math.hypot(dx,dy)||1;
      const minR = diskR + ballR + 0.5; if(r < minR){ pos.x = cx + dx*(minR/r); pos.y = cy + dy*(minR/r); }
    }

    function verletStep(dt){
      let maxT=0;
      for(const b of balls){
        // integrate with air drag
        const vx=(b.pos.x-b.prev.x)*(1-drag);
        const vy=(b.pos.y-b.prev.y)*(1-drag);
        b.prev = {x:b.pos.x, y:b.pos.y};
        b.pos.x += vx; b.pos.y += vy;

        const a = anchorOf(b);

        // 1) rope must stay outside disk body (no cutting)
        enforceHalfSpace(b.pos, a);

        // 2) elastic rope (partial length correction + line damping)
        let dx=b.pos.x-a.x, dy=b.pos.y-a.y; let dist=Math.hypot(dx,dy)||1e-6;
        let nx=dx/dist, ny=dy/dist; // direction from anchor to ball
        const corr = dist - L0;              // +: stretched, -: slack
        const corrApply = k * corr;          // 0..1 fraction per step
        b.pos.x -= nx * corrApply; b.pos.y -= ny * corrApply;

        // line-direction damping (spring damper)
        const nvx=b.pos.x-b.prev.x, nvy=b.pos.y-b.prev.y;
        const vAlong=(nvx*nx+nvy*ny)/Math.max(dt,1e-6);
        const damp = c * vAlong * dt;       // reduce along-line motion
        b.pos.x -= nx * damp; b.pos.y -= ny * damp;

        // 3) solid disk collision for the ball itself
        collideDisk(b.pos);

        // Tension estimate: spring stretch + centripetal component
        dx=b.pos.x-a.x; dy=b.pos.y-a.y; dist=Math.hypot(dx,dy)||1e-6; nx=dx/dist; ny=dy/dist;
        const tvx=(b.pos.x-b.prev.x) - ((b.pos.x-b.prev.x)*nx + (b.pos.y-b.prev.y)*ny)*nx;
        const tvy=(b.pos.y-b.prev.y) - ((b.pos.x-b.prev.x)*nx + (b.pos.y-b.prev.y)*ny)*ny;
        const vt2=(tvx*tvx+tvy*tvy)/Math.max(dt*dt,1e-6);
        const T = Math.max(0, k*Math.max(0,dist-L0)) + vt2/Math.max(L0,1e-3);
        b.tension=T; if(T>maxT) maxT=T;
      }
      return maxT;
    }

    function updateUI(){
      omegaOut.textContent = `${omega.toFixed(3)} rad/s`;
      timeOut.textContent  = `${elapsed.toFixed(2)} s`;
    }

    function drawScene(){
      const {width,height}=canvas; ctx.clearRect(0,0,width,height);
      // disk glow
      ctx.save(); ctx.translate(cx,cy);
      const grad=ctx.createRadialGradient(0,0,diskR*.2,0,0,diskR*1.6);
      grad.addColorStop(0,'rgba(77,195,255,0.20)'); grad.addColorStop(1,'rgba(77,195,255,0.00)');
      ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(0,0,diskR*1.7,0,Math.PI*2); ctx.fill(); ctx.restore();

      // disk body (rotating)
      ctx.save(); ctx.translate(cx,cy); ctx.rotate(diskAngle);
      const g=ctx.createLinearGradient(0,-diskR,0,diskR); g.addColorStop(0,'#dff5ff'); g.addColorStop(1,'#9fdcff');
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,diskR,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.lineWidth=3;
      for(let s=0;s<6;s++){ ctx.save(); ctx.rotate((s*Math.PI*2)/6); ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(diskR*.92,0); ctx.stroke(); ctx.restore(); }
      ctx.restore();

      // ropes & balls
      for(const b of balls){
        const a=anchorOf(b);
        const t = Math.min(1, b.tension / 0.05);
        ctx.strokeStyle=`rgba(160,200,255,${0.25+0.65*t})`; ctx.lineWidth=1+3*t;
        ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.pos.x,b.pos.y); ctx.stroke();
        // anchor nub
        ctx.fillStyle='#0c1219'; ctx.beginPath(); ctx.arc(a.x,a.y,4,0,Math.PI*2); ctx.fill();
        // ball
        ctx.fillStyle='#d6f2ff'; ctx.beginPath(); ctx.arc(b.pos.x,b.pos.y,ballR,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(77,195,255,0.7)'; ctx.beginPath(); ctx.arc(b.pos.x-ballR*.6,b.pos.y-ballR*.6,Math.max(3,ballR*.35),0,Math.PI*2); ctx.fill();
      }
    }

    function loop(ts){
      if(!running) return; if(!lastTS) lastTS=ts;
      const dt=Math.min(0.033,(ts-lastTS)/1000); lastTS=ts; elapsed+=dt; fpsTimer+=dt; frames++;
      // disk kinematics
      diskAngle += omega*dt; secondBucket += dt;
      if(secondBucket>=1){ const steps=Math.floor(secondBucket); secondBucket-=steps; for(let i=0;i<steps;i++) omega*=accel; }
      // integrate
      const maxT=verletStep(dt); tensionOut.textContent=maxT.toFixed(3)+' arb.';
      if(fpsTimer>=0.25){ fpsOut.textContent=`${Math.round(frames/fpsTimer)}`; fpsTimer=0; frames=0; }
      drawScene(); updateUI(); requestAnimationFrame(loop);
    }

    // ==== UI bindings ====
    ballsEl.addEventListener('input',()=>resetWorld());
    accelEl.addEventListener('input',()=>setParams());
    lenEl.addEventListener('change',()=>resetWorld());
    stiffEl.addEventListener('change',()=>setParams());
    sdampEl.addEventListener('change',()=>setParams());
    dragEl.addEventListener('change',()=>setParams());
    bradEl.addEventListener('change',()=>setParams());
    omega0El.addEventListener('change',()=>setParams());

    startBtn.addEventListener('click',()=>{ if(!running){ running=true; lastTS=0; requestAnimationFrame(loop);} });
    pauseBtn.addEventListener('click',()=>{ running=false; });
    resetBtn.addEventListener('click',()=>{ running=false; resetWorld(); });

    // ==== boot ====
    function boot(){ resize(); setParams(); resetWorld(); drawScene(); }
    boot();
  </script>
</body>
</html>
