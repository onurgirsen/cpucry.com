<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Particle Rain — O(n²) Collisions</title>
<style>
  :root { --bg:#0b1020; --fg:#e9f0ff; --muted:#9fb3ff22; --accent:#6ca0ff; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.2 system-ui,Segoe UI,Roboto,Arial}
  #wrap{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr}
  header{display:flex;gap:.5rem;align-items:center;padding:.6rem .8rem;background:#0f1630;border-bottom:1px solid #1b2550}
  header h1{font-size:14px;margin:0 1rem 0 0;color:#cfe0ff;font-weight:600;letter-spacing:.2px}
  button, input[type=checkbox] + label, .pill {
    background:#16204a;color:var(--fg);border:1px solid #26306a;border-radius:8px;padding:.5rem .7rem;
    cursor:pointer; font-weight:600;
  }
  button:hover{background:#1a2757}
  .danger{background:#4a1620;border-color:#6a2630} .danger:hover{background:#57212a}
  .ok{background:#163a4a;border-color:#265a6a} .ok:hover{background:#1a4757}
  #hud{position:absolute;left:10px;top:64px;background:#0b1020cc;border:1px solid #1b2550;border-radius:10px;
       padding:.6rem .8rem;backdrop-filter: blur(4px); pointer-events:none; }
  #hud .k{opacity:.8} #hud .v{font-weight:700}
  #canvas{display:block;width:100%;height:100%;background:
      radial-gradient(1200px 600px at 10% -10%, #142046 0%, #0b1020 60%)}
  .spacer{flex:1}
  .toggle{display:flex;gap:.5rem;align-items:center}
  .muted{opacity:.7}
  .tag{padding:.2rem .45rem;border-radius:999px;background:#19234d;border:1px solid #26306a;margin-left:.4rem;font-size:12px}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>Particle Rain <span class="tag">O(n²)</span></h1>
    <button id="startBtn" class="ok">Start</button>
    <button id="pauseBtn">Pause</button>
    <button id="panicBtn" class="danger">PANIC</button>
    <div class="spacer"></div>
    <button id="add100">+100 particles</button>
    <div class="toggle">
      <input type="checkbox" id="crash" />
      <label for="crash">Crash mode</label>
    </div>
    <div class="toggle">
      <input type="checkbox" id="trails" checked/>
      <label for="trails">Trails</label>
    </div>
  </header>
  <canvas id="canvas"></canvas>
</div>

<div id="hud">
  <div><span class="k">FPS:</span> <span id="fps" class="v">—</span></div>
  <div><span class="k">Particles:</span> <span id="count" class="v">0</span></div>
  <div><span class="k">Pair checks/frame:</span> <span id="pairs" class="v">0</span></div>
  <div><span class="k">Complexity:</span> <span class="v">O(n²)</span></div>
  <div class="muted" style="margin-top:.3rem">Keyboard: <b>Space</b> start/pause, <b>Esc</b> panic.</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  const hud = {
    fps: document.getElementById('fps'),
    count: document.getElementById('count'),
    pairs: document.getElementById('pairs'),
  };

  // UI
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const panicBtn = document.getElementById('panicBtn');
  const add100Btn = document.getElementById('add100');
  const crashToggle = document.getElementById('crash');
  const trailsToggle = document.getElementById('trails');

  // State
  let W=0,H=0;
  let particles = [];
  let running = false;
  let raf = 0;

  let growthPeriodMs = 4000; // double count every 4 seconds
  let lastGrowth = 0;
  let safeCap = 2000; // particle cap while Crash mode is OFF
  let lastTime = performance.now();
  let fpsEMA = 0; // exponential moving average of FPS

  function resize() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    W = canvas.clientWidth;
    H = canvas.clientHeight;
  }
  addEventListener('resize', resize);

  // Particle
  class P {
    constructor(x,y,vx,vy,r,h) {
      this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.r=r; this.h=h; this.hu=h;
    }
    step(dt) {
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      // bounce off walls
      if (this.x < this.r){ this.x=this.r; this.vx*=-1; }
      if (this.x > W-this.r){ this.x=W-this.r; this.vx*=-1; }
      if (this.y < this.r){ this.y=this.r; this.vy*=-1; }
      if (this.y > H-this.r){ this.y=H-this.r; this.vy*=-1; }
      // slowly shift hue
      this.hu = (this.hu + 30*dt) % 360;
    }
    draw() {
      ctx.beginPath();
      ctx.fillStyle = `hsl(${this.hu}, 90%, 60%)`;
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function rand(a,b){ return a + Math.random()*(b-a); }

  function addParticles(n=100){
    for(let i=0;i<n;i++){
      const r = rand(2,4);
      particles.push(new P(rand(r,W-r), rand(r,H-r), rand(-60,60), rand(-60,60), r, Math.random()*360));
    }
    updateHUD();
  }

  function clearAll(){
    particles.length = 0;
    updateHUD();
    // instant clear
    ctx.clearRect(0,0,W,H);
  }

  function updateHUD() {
    const n = particles.length|0;
    hud.count.textContent = n.toString();
    const pairs = (n*(n-1)/2)|0;
    hud.pairs.textContent = pairs.toLocaleString('en-US');
  }

  function maybeGrow(now){
    if (now - lastGrowth >= growthPeriodMs){
      lastGrowth = now;
      const target = crashToggle.checked ? particles.length*2 : Math.min(particles.length*2, safeCap);
      const need = Math.max(0, target - particles.length);
      if (need>0) addParticles(need);
    }
  }

  function start(){
    if (running) return;
    running = true;
    lastTime = performance.now();
    lastGrowth = lastTime;
    loop();
  }
  function pause(){
    running = false;
    cancelAnimationFrame(raf);
  }

  function loop(){
    if (!running) return;
    raf = requestAnimationFrame(loop);

    const now = performance.now();
    const dt = Math.min((now - lastTime)/1000, 0.05); // clamp dt
    lastTime = now;

    // FPS (EMA)
    const fps = 1/Math.max(dt,1e-6);
    fpsEMA = fpsEMA ? (fpsEMA*0.9 + fps*0.1) : fps;

    // If frame budget collapses and Crash mode is OFF, gently trim
    if (!crashToggle.checked && fpsEMA < 12 && particles.length > 400) {
      const cut = Math.floor(particles.length * 0.05);
      particles.length = Math.max(100, particles.length - cut);
      updateHUD();
    }

    step(dt, now);
    draw(trailsToggle.checked);
    hud.fps.textContent = fpsEMA.toFixed(0);

    maybeGrow(now);
  }

  function step(dt, now){
    const n = particles.length;
    // movement
    for (let i=0;i<n;i++) particles[i].step(dt);

    // naive O(n²) collision + proximity line
    const linkDist = 32; const linkDist2 = linkDist*linkDist;
    for (let i=0;i<n;i++){
      const a = particles[i];
      for (let j=i+1;j<n;j++){
        const b = particles[j];
        const dx = b.x - a.x, dy = b.y - a.y;
        const rr = (a.r + b.r); const d2 = dx*dx + dy*dy;

        // if close, draw a faint line (extra cost)
        if (d2 < linkDist2){
          ctx.beginPath();
          ctx.globalAlpha = 0.08;
          ctx.strokeStyle = '#86a5ff';
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }

        // collision: swap velocities (cheap & lively)
        if (d2 <= rr*rr){
          const tmpx = a.vx, tmpy = a.vy;
          a.vx = b.vx; a.vy = b.vy;
          b.vx = tmpx; b.vy = tmpy;

          // small separation nudge
          const d = Math.max(Math.sqrt(d2), 0.001);
          const nx = dx/d, ny = dy/d;
          const overlap = rr - d + 0.5;
          a.x -= nx * overlap*0.5; a.y -= ny * overlap*0.5;
          b.x += nx * overlap*0.5; b.y += ny * overlap*0.5;

          // color pop on hit
          const h = (a.hu + b.hu)/2;
          a.hu = (h + 30) % 360; b.hu = (h + 330) % 360;
        }
      }
    }
  }

  function draw(withTrails){
    if (withTrails) {
      // trail effect: translucent veil
      ctx.fillStyle = 'rgba(11,16,32,0.12)';
      ctx.fillRect(0,0,W,H);
    } else {
      ctx.clearRect(0,0,W,H);
    }
    for (let i=0;i<particles.length;i++) particles[i].draw();
    updateHUD();
  }

  // Controls
  startBtn.addEventListener('click', () => start());
  pauseBtn.addEventListener('click', () => pause());
  panicBtn.addEventListener('click', () => { pause(); clearAll(); });
  add100Btn.addEventListener('click', () => { addParticles(100); });

  // Keyboard
  addEventListener('keydown', (e)=>{
    if (e.code === 'Space'){ e.preventDefault(); running ? pause() : start(); }
    if (e.code === 'Escape'){ e.preventDefault(); pause(); clearAll(); }
  });

  // Init
  resize();
  addParticles(120); // initial seed
  draw(false); // paint once

})();
</script>
</body>
</html>
