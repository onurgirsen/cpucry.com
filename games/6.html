<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Physics-based simulation of a ball bouncing within an expanding circle with adjustable growth factor and performance chart." />
  <meta name="keywords" content="circular bounce simulation, physics simulation, browser game, computer crashing games, hardware stress test" />
  <meta name="robots" content="index, follow" />
  <meta property="og:title" content="Circular Bounce Simulation" />
  <meta property="og:description" content="Physics-based simulation of a ball bouncing within an expanding circle with adjustable growth factor and performance chart." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://www.cpucry.com/games/6.html" />
  <meta property="og:image" content="https://www.cpucry.com/images/6.png" />
  <link rel="canonical" href="https://www.cpucry.com/games/6.html" />
  <title>Circular Bounce Simulation</title>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "VideoGame",
    "name": "Circular Bounce Simulation",
    "url": "https://www.cpucry.com/games/6.html",
    "applicationCategory": "BrowserGame",
    "operatingSystem": "Web",
    "genre": "Simulation, Physics",
    "author": {"@type": "Person", "name": "Onur Girşen"},
    "description": "Physics-based simulation of a ball bouncing within an expanding circle with adjustable growth factor and performance chart."
  }
  </script>
  <style>
    :root{
      --panel-bg: rgba(20,22,28,0.6);
      --panel-border: rgba(255,255,255,0.12);
      --text: #e9eef5;
      --accent: #67e8f9;
    }
    html, body{
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 50% 30%, #0f172a 0%, #0b1220 40%, #090f1a 100%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap{
      position: relative;
      height: 100dvh;
      width: 100vw;
      overflow: hidden;
    }
    #sim{
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
    .panel{
      position: absolute;
      left: 18px;
      bottom: 18px;
      width: clamp(260px, 26vw, 360px);
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.06);
      backdrop-filter: blur(10px) saturate(110%);
      -webkit-backdrop-filter: blur(10px) saturate(110%);
      padding: 14px 14px 6px;
    }
    .panel h2{
      margin: 0 0 8px;
      font-size: 14px;
      letter-spacing: 0.25px;
      color: #cbd5e1;
      font-weight: 600;
      display: flex; align-items: center; gap: 8px;
    }
    .row{ margin: 10px 0 16px; }
    label{
      display: flex; justify-content: space-between; align-items: baseline;
      font-size: 12px; color: #cbd5e1; margin-bottom: 6px;
    }
    output{ font-variant-numeric: tabular-nums; color: #fff; }
    input[type="range"]{ width: 100%; }
    input[type="range"] { appearance: none; height: 6px; border-radius: 999px; background: rgba(255,255,255,0.15); outline: none; }
    input[type="range"]::-webkit-slider-thumb{ appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--accent); border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.35); cursor: pointer; }
    input[type="range"]::-moz-range-thumb{ width: 16px; height: 16px; border-radius: 50%; background: var(--accent); border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.35); cursor: pointer; }

    .btn{
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      color: #fff; font-weight: 600; letter-spacing: 0.2px; cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.2s;
    }
    .btn:hover{ transform: translateY(-1px); box-shadow: 0 6px 18px rgba(0,0,0,0.25); }
    .btn:active{ transform: translateY(0); }

    .chart{
      position: absolute;
      right: 18px; bottom: 18px;
      width: min(380px, 38vw);
      height: min(200px, 26vh);
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.06);
      backdrop-filter: blur(10px) saturate(110%);
      -webkit-backdrop-filter: blur(10px) saturate(110%);
      padding: 10px 12px 12px;
      display: grid; grid-template-rows: auto 1fr; gap: 8px;
    }
    .chart .hdr{ display:flex; justify-content:space-between; align-items: baseline; font-size: 12px; color:#cbd5e1; }
    .chart .hdr b{ color:#fff; font-size: 13px; }
    #chart{ width: 100%; height: 100%; display:block; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="sim"></canvas>
    <section class="panel" aria-label="Control Panel">
      <h2>Control Panel ⚙️</h2>

      <div class="row">
        <label for="factor">Growth factor (x)
          <output id="factorOut">1.01</output>
        </label>
        <input id="factor" type="range" min="0.8" max="5" step="0.1" value="1.01" />
      </div>

      <div class="row">
        <label for="diameter">Circle diameter (px)
          <output id="diameterOut">—</output>
        </label>
        <input id="diameter" type="range" min="200" max="1200" step="1" />
      </div>

      <button class="btn" id="reset">Reset</button>
    </section>

    <section class="chart" aria-label="Ball Size Chart">
      <div class="hdr">
        <span>Ball radius (px)</span>
        <span>Now: <b id="radiusNow">1.0</b></span>
      </div>
      <canvas id="chart"></canvas>
    </section>
  </div>

  <script>
    // ====== Canvas & DPR helpers ======
    const $ = sel => document.querySelector(sel);
    const sim = $('#sim');
    const chart = $('#chart');
    const factorInput = $('#factor');
    const factorOut = $('#factorOut');
    const diameterInput = $('#diameter');
    const diameterOut = $('#diameterOut');
    const resetBtn = $('#reset');
    const radiusNow = $('#radiusNow');

    function fitCanvas(canvas){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.max(1, Math.floor(rect.width * dpr));
      canvas.height = Math.max(1, Math.floor(rect.height * dpr));
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      return ctx;
    }

    let ctx = fitCanvas(sim);
    let cctx = fitCanvas(chart);

    // ====== Simulation state ======
    const state = {
      center: {x: 0, y: 0},
      R: 300,             // circle radius (px); will be set in setDefaults
      ball: {
        p: {x: 0, y: 0},  // position
        v: {x: 0, y: 0},  // velocity
        r: 1,             // radius (px)
      },
      gravity: 1500,      // px/s^2 downward
      last: performance.now(),
      running: true,
      growth: parseFloat(factorInput.value),
      bounceCount: 0,
    };

    function setDefaults(){
      // Center
      state.center.x = sim.clientWidth / 2;
      state.center.y = sim.clientHeight / 2;

      // Slider bounds depend on viewport size
      const minSide = Math.min(sim.clientWidth, sim.clientHeight);
      diameterInput.min = 100;
      diameterInput.max = Math.max(200, Math.floor(minSide * 0.95));

      // Desired default diameter is 600 px
      const desiredD = 600;
      const chosenD = Math.max(parseInt(diameterInput.min), Math.min(parseInt(diameterInput.max), desiredD));
      diameterInput.value = String(chosenD);
      diameterOut.textContent = diameterInput.value;
      state.R = Math.max(10, Math.floor(chosenD/2));

      // Ball initial state
      state.ball.r = 1;
      state.ball.v.x = (Math.random() < 0.5 ? -1 : 1) * 120; // small horizontal speed
      state.ball.v.y = 0;
      // Start near the top, inside the circle
      state.ball.p.x = state.center.x;
      state.ball.p.y = state.center.y - (state.R - 50);
      state.bounceCount = 0;

      // Default growth factor display (request: 1.01)
      factorOut.textContent = parseFloat(factorInput.value).toFixed(2);
      radiusNow.textContent = state.ball.r.toFixed(1);
    }

    // Keep ball inside after geometry changes
    function clampInside(){
      const dx = state.ball.p.x - state.center.x;
      const dy = state.ball.p.y - state.center.y;
      const dist = Math.hypot(dx, dy) || 1e-6;
      const maxDist = Math.max(0, state.R - state.ball.r - 0.5);
      if(dist > maxDist){
        const n = {x: dx/dist, y: dy/dist};
        state.ball.p.x = state.center.x + n.x * maxDist;
        state.ball.p.y = state.center.y + n.y * maxDist;
      }
    }

    // ====== Physics step ======
    function step(dt){
      if(!state.running) return;
      // 1) Integrate velocity with gravity
      state.ball.v.y += state.gravity * dt;

      // 2) Tentative position
      let nx = state.ball.p.x + state.ball.v.x * dt;
      let ny = state.ball.p.y + state.ball.v.y * dt;

      // 3) Collision with inner boundary of the circle (radius R - r)
      const dx = nx - state.center.x;
      const dy = ny - state.center.y;
      const dist = Math.hypot(dx, dy);
      const limit = state.R - state.ball.r;

      if(dist > limit){
        // Move to boundary along normal
        const n = {x: dx / dist, y: dy / dist};
        nx = state.center.x + n.x * limit;
        ny = state.center.y + n.y * limit;
        // Reflect velocity: v' = v - 2*(v·n)*n
        const dot = state.ball.v.x * n.x + state.ball.v.y * n.y;
        state.ball.v.x = state.ball.v.x - 2 * dot * n.x;
        state.ball.v.y = state.ball.v.y - 2 * dot * n.y;

        // Bounce event: grow radius by factor
        state.bounceCount++;
        const newR = Math.max(0.1, Math.min(state.R - 1, state.ball.r * state.growth));
        state.ball.r = newR;
        // Pull slightly inward to avoid sticking after growth
        // After growth, push strictly inside by a fixed safety margin to avoid re-collision
        const limitNew = state.R - state.ball.r;
        const safety = 1; // px
        const target = Math.max(0, limitNew - safety);
        nx = state.center.x + n.x * target;
        ny = state.center.y + n.y * target;
        flash();
        // Inject a tiny, constant bounce energy: 1.001x (independent of growth)
        {
          const speed = Math.hypot(state.ball.v.x, state.ball.v.y);
          if (speed > 0) {
            const scale = 1.001; // constant energy boost
            state.ball.v.x *= scale;
            state.ball.v.y *= scale;
            // numerical stability cap
            const vmax = 8000;
            const vmag = Math.hypot(state.ball.v.x, state.ball.v.y);
            if (vmag > vmax) {
              const k = vmax / vmag;
              state.ball.v.x *= k;
              state.ball.v.y *= k;
            }
          }
        }
      }

      state.ball.p.x = nx;
      state.ball.p.y = ny;
    }

    // ====== Rendering ======
    function render(){
      ctx.clearRect(0,0,sim.clientWidth, sim.clientHeight);
      const {x: cx, y: cy} = state.center;

      // Circle
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, state.R, 0, Math.PI*2);
      const grad = ctx.createRadialGradient(cx, cy, state.R*0.6, cx, cy, state.R);
      grad.addColorStop(0, 'rgba(255,255,255,0.03)');
      grad.addColorStop(1, 'rgba(255,255,255,0.10)');
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.stroke();
      ctx.restore();

      // Ball
      ctx.save();
      ctx.beginPath();
      ctx.arc(state.ball.p.x, state.ball.p.y, state.ball.r, 0, Math.PI*2);
      const g = ctx.createRadialGradient(state.ball.p.x - state.ball.r*0.4, state.ball.p.y - state.ball.r*0.4, state.ball.r*0.2, state.ball.p.x, state.ball.p.y, state.ball.r);
      g.addColorStop(0, '#a5b4fc');
      g.addColorStop(1, '#3b82f6');
      ctx.fillStyle = g;
      ctx.fill();
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.stroke();
      ctx.restore();

      // HUD
      radiusNow.textContent = state.ball.r.toFixed(1);
    }

    // ====== Chart (radius over time) ======
    const history = []; // {t, r}
    const WINDOW_SEC = 20; // show last 20 seconds

    function pushHistory(t){
      history.push({t, r: state.ball.r});
      // drop old
      const cutoff = t - WINDOW_SEC;
      while(history.length && history[0].t < cutoff){ history.shift(); }
    }

    function drawChart(){
      cctx.clearRect(0,0,chart.clientWidth, chart.clientHeight);
      const w = chart.clientWidth, h = chart.clientHeight;
      const pad = {l: 36, r: 6, t: 10, b: 20};
      const innerW = Math.max(1, w - pad.l - pad.r);
      const innerH = Math.max(1, h - pad.t - pad.b);

      // Axes
      cctx.strokeStyle = 'rgba(255,255,255,0.15)';
      cctx.lineWidth = 1;
      cctx.beginPath();
      cctx.moveTo(pad.l, pad.t);
      cctx.lineTo(pad.l, h - pad.b);
      cctx.lineTo(w - pad.r, h - pad.b);
      cctx.stroke();

      if(history.length < 2) return;

      const tMin = history[0].t;
      const tMax = history[history.length-1].t;
      let rMin = Infinity, rMax = -Infinity;
      for(const d of history){ rMin = Math.min(rMin, d.r); rMax = Math.max(rMax, d.r); }
      if(rMin === rMax){ rMax += 1; rMin -= 1; }
      const padY = (rMax - rMin) * 0.1;
      rMax += padY; rMin = Math.max(0, rMin - padY);

      function xScale(t){ return pad.l + ( (t - tMin) / Math.max(0.001, (tMax - tMin)) ) * innerW; }
      function yScale(r){ return pad.t + (1 - (r - rMin)/Math.max(0.001, (rMax - rMin))) * innerH; }

      // Line
      cctx.lineWidth = 2;
      cctx.strokeStyle = 'rgba(103,232,249,0.9)';
      cctx.beginPath();
      cctx.moveTo(xScale(history[0].t), yScale(history[0].r));
      for(let i=1;i<history.length;i++){
        cctx.lineTo(xScale(history[i].t), yScale(history[i].r));
      }
      cctx.stroke();

      // Y ticks (min, mid, max)
      cctx.fillStyle = 'rgba(255,255,255,0.7)';
      cctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      const ticks = [rMin, (rMin+rMax)/2, rMax];
      for(const t of ticks){
        const y = yScale(t);
        cctx.globalAlpha = 0.35;
        cctx.beginPath(); cctx.moveTo(pad.l, y); cctx.lineTo(w - pad.r, y); cctx.stroke();
        cctx.globalAlpha = 1;
        cctx.fillText(t.toFixed(1), 6, y + 4);
      }
    }

    // Small flash on bounce
    let flashAlpha = 0;
    function flash(){ flashAlpha = 0.6; }
    function drawFlash(){
      if(flashAlpha <= 0) return;
      ctx.save();
      ctx.globalAlpha = flashAlpha;
      ctx.beginPath();
      ctx.arc(state.center.x, state.center.y, state.R, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(103,232,249,1)';
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.restore();
      flashAlpha *= 0.9;
    }

    // ====== Animation loop ======
    function loop(now){
      const dtRaw = Math.min(32, now - state.last) / 1000; // cap to 32ms
      state.last = now;

      step(dtRaw);
      render();
      drawFlash();

      const tSec = now / 1000;
      pushHistory(tSec);
      drawChart();

      requestAnimationFrame(loop);
    }

    // ====== Events ======
    function onResize(){
      ctx = fitCanvas(sim);
      cctx = fitCanvas(chart);
      state.center.x = sim.clientWidth / 2;
      state.center.y = sim.clientHeight / 2;
      clampInside();
      drawChart();
    }
    window.addEventListener('resize', onResize);

    factorInput.addEventListener('input', () => {
      state.growth = parseFloat(factorInput.value);
      factorOut.textContent = state.growth.toFixed(2);
    });

    diameterInput.addEventListener('input', () => {
      const d = parseInt(diameterInput.value, 10);
      state.R = Math.max(10, Math.floor(d/2));
      diameterOut.textContent = d;
      clampInside();
    });

    resetBtn.addEventListener('click', () => {
      const keepR = 1; // reset to 1px as requested
      state.ball.r = keepR;
      state.ball.v.x = (Math.random() < 0.5 ? -1 : 1) * 120;
      state.ball.v.y = 0;
      state.ball.p.x = state.center.x;
      state.ball.p.y = state.center.y - (state.R - 50);
      state.bounceCount = 0;
      history.length = 0;
    });

    // ====== Init ======
    setDefaults();
    onResize();
    requestAnimationFrame(ts => { state.last = ts; loop(ts); });
  </script>
</body>
</html>
