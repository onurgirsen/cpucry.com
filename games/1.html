<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Interactive 7/8 ring simulation and computer crashing game to stress your hardware." />
    <meta name="keywords" content="computer crashing games, ring simulation, CPU stress test, browser physics, hardware performance" />
    <meta name="robots" content="index, follow" />
    <meta property="og:title" content="7/8 Ring Simulation" />
    <meta property="og:description" content="Interactive 7/8 ring simulation and computer crashing game to stress your hardware." />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.cpucry.com/games/1.html" />
    <link rel="canonical" href="https://www.cpucry.com/games/1.html" />
    <title>7/8 Ring Simulation</title>
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "7/8 Ring Simulation",
      "url": "https://www.cpucry.com/games/1.html",
      "applicationCategory": "BrowserGame",
      "operatingSystem": "Web",
      "genre": "Arcade, Physics",
      "author": {"@type": "Person", "name": "Onur Girşen"},
      "description": "Interactive 7/8 ring simulation and computer crashing game to stress your hardware."
    }
    </script>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: #0f1220;
        color: #e8ecf1;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }

      #ui {
        position: fixed;
        bottom: 72px; /* above the hint */
        left: 10px;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 6px;
        padding: 8px 10px;
        background: linear-gradient(180deg, rgba(12,14,26,0.9), rgba(12,14,26,0.6));
        backdrop-filter: blur(6px);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 10px;
        z-index: 10;
        max-width: min(96vw, 360px);
      }

      #ui .control {
        display: flex;
        align-items: center;
        gap: 6px;
        width: 100%;
      }

      #ui label {
        font-size: 12px;
        opacity: 0.9;
        white-space: nowrap;
      }

      #ui input[type="range"] {
        width: 160px;
      }

      #ui .value {
        font-variant-numeric: tabular-nums;
        min-width: 48px;
        text-align: right;
        font-size: 12px;
      }

      #canvas {
        position: absolute;
        inset: 0;
        display: block;
      }

      #chartCanvas {
        position: fixed;
        top: 10px;
        right: 10px;
        width: 320px;
        height: 100px;
        background: rgba(20, 24, 40, 0.7);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 8px;
        box-shadow: 0 2px 12px rgba(0,0,0,0.35);
        z-index: 5;
      }

      #ui button {
        margin-left: 0;
        background: #1e2a52;
        color: #e8ecf1;
        border: 1px solid rgba(255,255,255,0.15);
        border-radius: 6px;
        padding: 4px 8px;
        font-size: 12px;
        cursor: pointer;
      }

      #ui button:hover {
        background: #233060;
      }

      .hint {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 12px;
        opacity: 0.6;
        user-select: none;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <div class="control">
        <label for="restitution">Bounciness</label>
        <input id="restitution" type="range" min="0" max="1" step="0.01" value="0.85" />
        <span class="value" id="restitutionValue">0.85</span>
      </div>
      <div class="control">
        <label for="gap">Gap</label>
        <input id="gap" type="range" min="0.05" max="0.5" step="0.005" value="0.125" />
        <span class="value" id="gapValue">12.5%</span>
      </div>
      <div class="control">
        <label for="rotation">Rotation speed</label>
        <input id="rotation" type="range" min="-180" max="180" step="1" value="30" />
        <span class="value" id="rotationValue">30°/s</span>
      </div>
      <div class="control">
        <button id="resetBtn" title="Clear all balls and restart">Reset balls</button>
      </div>
    </div>
    <canvas id="canvas"></canvas>
    <canvas id="chartCanvas"></canvas>
    <div class="hint">The gap is adjustable (initially 1/8). The ring rotates continuously. For each ball that exits, 2 new balls spawn at the center.</div>

    <script>
      (function () {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const chartCtx = chartCanvas.getContext('2d');

        // UI: restitution (bounciness)
        const restitutionInput = document.getElementById('restitution');
        const restitutionValueText = document.getElementById('restitutionValue');
        // UI: gap fraction
        const gapInput = document.getElementById('gap');
        const gapValueText = document.getElementById('gapValue');
        // UI: rotation speed (deg/s)
        const rotationInput = document.getElementById('rotation');
        const rotationValueText = document.getElementById('rotationValue');

        // Device pixel ratio for crisp rendering
        function resizeCanvas() {
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          const { innerWidth: w, innerHeight: h } = window;
          canvas.width = Math.floor(w * dpr);
          canvas.height = Math.floor(h * dpr);
          canvas.style.width = w + 'px';
          canvas.style.height = h + 'px';
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function resizeChart() {
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          const rect = chartCanvas.getBoundingClientRect();
          chartCanvas.width = Math.max(1, Math.floor(rect.width * dpr));
          chartCanvas.height = Math.max(1, Math.floor(rect.height * dpr));
          chartCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        window.addEventListener('resize', () => { resizeCanvas(); resizeChart(); });
        resizeCanvas();
        resizeChart();

        // World parameters
        let restitution = parseFloat(restitutionInput.value); // 0..1
        restitutionValueText.textContent = restitution.toFixed(2);
        restitutionInput.addEventListener('input', () => {
          restitution = parseFloat(restitutionInput.value);
          restitutionValueText.textContent = restitution.toFixed(2);
        });

        const ring = {
          rotationRad: 0,
          angularVelocity: (Math.PI / 180) * 30, // 30 deg/s
          gapAngleRad: (2 * Math.PI) / 8, // 1/8 open
          radiusPx: 200,
          strokePx: 12,
        };

        const balls = [];
        const toSpawnQueue = [];
        const resetBtn = document.getElementById('resetBtn');
        resetBtn.addEventListener('click', () => {
          balls.length = 0;
          toSpawnQueue.length = 0;
          spawnAtCenter(1);
        });
        const spawnAtCenter = (count = 1) => {
          for (let i = 0; i < count; i++) {
            const speed = 220 + Math.random() * 120; // px/s
            const angle = Math.random() * Math.PI * 2;
            const velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
            balls.push({
              x: 0,
              y: 0,
              vx: velocity.x,
              vy: velocity.y,
              radius: 8,
              color: randomNiceColor(),
              lifeMs: 0,
            });
          }
        };

        // Gap initial sync
        let gapFraction = parseFloat(gapInput.value);
        gapValueText.textContent = (gapFraction * 100).toFixed(1) + '%';
        ring.gapAngleRad = 2 * Math.PI * gapFraction;

        gapInput.addEventListener('input', () => {
          gapFraction = parseFloat(gapInput.value);
          gapValueText.textContent = (gapFraction * 100).toFixed(1) + '%';
          ring.gapAngleRad = 2 * Math.PI * gapFraction;
        });

        // Rotation speed sync (deg/s -> rad/s)
        function degToRad(deg) { return (deg * Math.PI) / 180; }
        let rotationDegPerSec = parseFloat(rotationInput.value);
        rotationValueText.textContent = `${rotationDegPerSec}\u00B0/s`;
        ring.angularVelocity = degToRad(rotationDegPerSec);

        rotationInput.addEventListener('input', () => {
          rotationDegPerSec = parseFloat(rotationInput.value);
          rotationValueText.textContent = `${rotationDegPerSec}\u00B0/s`;
          ring.angularVelocity = degToRad(rotationDegPerSec);
        });

        // Initial spawn
        spawnAtCenter(1);

        function randomNiceColor() {
          const hues = [200, 210, 220, 230, 260, 280];
          const h = hues[Math.floor(Math.random() * hues.length)];
          const s = 70 + Math.floor(Math.random() * 20);
          const l = 55 + Math.floor(Math.random() * 10);
          return `hsl(${h} ${s}% ${l}%)`;
        }

        function worldCenter() {
          return { x: canvas.clientWidth / 2, y: canvas.clientHeight / 2 };
        }

        function computeRingRadius() {
          const minDim = Math.min(canvas.clientWidth, canvas.clientHeight);
          // Leave UI space on top visually; but simulation is centered so it's fine.
          return Math.max(60, Math.floor(minDim * 0.35));
        }

        function isAngleInGap(pointAngle, ringRotation, gapAngle) {
          // Gap is centered at the ring's rotation angle
          let d = normalizeAngle(pointAngle - ringRotation);
          d = Math.abs(d);
          return d <= gapAngle * 0.5;
        }

        function normalizeAngle(a) {
          // Normalize to [-PI, PI]
          a = ((a + Math.PI) % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI) - Math.PI;
          return a;
        }

        function reflectVelocityOffCircle(ball, normalX, normalY) {
          // n must be unit vector
          const vDotN = ball.vx * normalX + ball.vy * normalY;
          const bounce = -(1 + restitution) * vDotN;
          ball.vx = ball.vx + bounce * normalX;
          ball.vy = ball.vy + bounce * normalY;
        }

        function integrate(dt) {
          // Update dynamic ring radius (responsive)
          ring.radiusPx = computeRingRadius();

          // Rotate ring
          ring.rotationRad += ring.angularVelocity * dt;
          ring.rotationRad = normalizeAngle(ring.rotationRad);

          // Simple global damping to keep energy in check
          const linearDamping = 0.002; // per second

          // World center
          const c = worldCenter();

          // Update balls
          for (let i = balls.length - 1; i >= 0; i--) {
            const b = balls[i];
            b.lifeMs += dt * 1000;

            // Integrate
            b.x += b.vx * dt;
            b.y += b.vy * dt;

            // Damping (exponential-like)
            const damp = Math.max(0, 1 - linearDamping * (dt * 60) / 60);
            b.vx *= damp;
            b.vy *= damp;

            // Compute polar relative to center
            const relX = b.x - 0; // center is (0,0) in local space
            const relY = b.y - 0;
            const dist = Math.hypot(relX, relY);
            const theta = Math.atan2(relY, relX);

            const effectiveRadius = ring.radiusPx - b.radius - ring.strokePx * 0.5;

            // Check if ball is outside the ring entirely -> considered exited if past outer edge sufficiently
            const exitThreshold = ring.radiusPx + b.radius + ring.strokePx; // a bit beyond stroke
            if (dist > exitThreshold) {
              // Remove and enqueue 2 spawns
              balls.splice(i, 1);
              toSpawnQueue.push(2);
              continue;
            }

            // If the ball wants to cross the boundary but not through the gap, collide
            const wantsToCross = dist > effectiveRadius;
            const inGap = isAngleInGap(theta, ring.rotationRad, ring.gapAngleRad);
            if (wantsToCross && !inGap) {
              // Project back onto boundary
              const normalX = relX / (dist || 1);
              const normalY = relY / (dist || 1);

              // Place on surface just inside
              b.x = normalX * effectiveRadius;
              b.y = normalY * effectiveRadius;

              // Reflect velocity
              reflectVelocityOffCircle(b, normalX, normalY);
            }
          }

          // Consume spawn queue
          while (toSpawnQueue.length > 0) {
            const count = toSpawnQueue.shift() || 0;
            spawnAtCenter(count);
          }
        }

        function render() {
          const w = canvas.clientWidth;
          const h = canvas.clientHeight;
          const c = worldCenter();

          ctx.clearRect(0, 0, w, h);

          // Subtle background vignette
          const grad = ctx.createRadialGradient(c.x, c.y, 10, c.x, c.y, Math.max(w, h) * 0.7);
          grad.addColorStop(0, '#0f1220');
          grad.addColorStop(1, '#0b0d1a');
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, w, h);

          // Draw rotating 7/8 ring
          ctx.save();
          ctx.translate(c.x, c.y);
          ctx.rotate(ring.rotationRad);
          ctx.beginPath();
          const start = ring.gapAngleRad * 0.5;
          const end = (Math.PI * 2) - ring.gapAngleRad * 0.5;
          ctx.arc(0, 0, ring.radiusPx, start, end, false);
          ctx.strokeStyle = 'rgba(120,160,255,0.9)';
          ctx.lineWidth = ring.strokePx;
          ctx.lineCap = 'round';
          ctx.stroke();
          ctx.restore();

          // Draw spawn point
          ctx.save();
          ctx.translate(c.x, c.y);
          ctx.fillStyle = 'rgba(255,255,255,0.85)';
          ctx.beginPath();
          ctx.arc(0, 0, 3, 0, Math.PI * 2);
          ctx.fill();

          // Draw balls (local coords are centered at world center for convenience)
          for (const b of balls) {
            ctx.beginPath();
            ctx.fillStyle = b.color;
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();

          // HUD: counts
          ctx.save();
          ctx.fillStyle = 'rgba(255,255,255,0.7)';
          ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
          ctx.fillText(`Balls: ${balls.length}`, 12, 52);
          ctx.restore();
        }

        // -------- Live Chart (balls count over time) --------
        const samples = []; // { tSec, n }
        const windowSec = 30; // last 30 seconds

        function recordSample(tSec, n) {
          samples.push({ tSec, n });
          const minT = tSec - windowSec;
          // prune old
          while (samples.length && samples[0].tSec < minT) samples.shift();
        }

        function renderChart(tSec) {
          const w = chartCanvas.clientWidth;
          const h = chartCanvas.clientHeight;
          chartCtx.clearRect(0, 0, w, h);

          // Background and border are via CSS; draw axes/grid
          const padL = 36;
          const padR = 8;
          const padT = 8;
          const padB = 18;
          const plotW = Math.max(1, w - padL - padR);
          const plotH = Math.max(1, h - padT - padB);

          // Compute y-scale
          let maxN = 1;
          for (const s of samples) maxN = Math.max(maxN, s.n);
          // Draw grid lines (4 horizontal)
          chartCtx.save();
          chartCtx.strokeStyle = 'rgba(255,255,255,0.08)';
          chartCtx.lineWidth = 1;
          chartCtx.beginPath();
          for (let i = 0; i <= 4; i++) {
            const y = padT + (i / 4) * plotH;
            chartCtx.moveTo(padL, y);
            chartCtx.lineTo(padL + plotW, y);
          }
          chartCtx.stroke();
          chartCtx.restore();

          // Axes labels (avoid overlap)
          chartCtx.save();
          chartCtx.fillStyle = 'rgba(255,255,255,0.6)';
          chartCtx.font = '11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
          chartCtx.fillText('Ball count', 6, 14);
          chartCtx.fillText(`${Math.round(maxN)}`, 6, padT + 20);
          chartCtx.fillText('0', 18, padT + plotH + 14);
          chartCtx.fillText('Last 30 s', w - 66, h - 6);
          chartCtx.restore();

          // Polyline
          if (samples.length >= 2) {
            chartCtx.save();
            chartCtx.strokeStyle = 'rgba(120,160,255,0.95)';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            const tMin = tSec - windowSec;
            for (let i = 0; i < samples.length; i++) {
              const s = samples[i];
              const x = padL + ((s.tSec - tMin) / windowSec) * plotW;
              const y = padT + (1 - (s.n / maxN)) * plotH;
              if (i === 0) chartCtx.moveTo(x, y);
              else chartCtx.lineTo(x, y);
            }
            chartCtx.stroke();
            chartCtx.restore();
          }
        }

        let lastTs = performance.now();
        function frame(now) {
          const rawDt = Math.min(0.05, (now - lastTs) / 1000); // clamp to 50ms
          lastTs = now;

          // Fixed sub-steps for stability if dt is large
          let remaining = rawDt;
          const step = 1 / 120; // 120 Hz substep
          while (remaining > 1e-6) {
            const dt = Math.min(step, remaining);
            integrate(dt);
            remaining -= dt;
          }

          render();
          const nowSec = now / 1000;
          recordSample(nowSec, balls.length);
          renderChart(nowSec);
          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      })();
    </script>
  </body>
</html>
